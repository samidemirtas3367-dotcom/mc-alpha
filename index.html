<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ALPHA ARCADE: INFINITY SUPREME</title>
    <style>
        /* CORE SYSTEM CSS */
        body { margin: 0; background: #000; color: #fff; font-family: 'Arial Black', sans-serif; overflow: hidden; touch-action: none; user-select: none; }
        #masterWrap { position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; background: radial-gradient(circle, #1a1a2e 0%, #000 100%); }
        
        canvas { background: #000; border: 6px solid #444; box-shadow: 0 0 120px rgba(0, 255, 242, 0.25); image-rendering: pixelated; display: none; }

        /* NEON SUPREME MENU */
        #mainMenu { position: absolute; z-index: 1000; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.96); backdrop-filter: blur(20px); }
        .arcade-logo { font-size: 65px; font-weight: 900; color: #00fff2; text-shadow: 6px 6px #ff00ff, 0 0 40px #00fff2; letter-spacing: 15px; margin-bottom: 50px; text-transform: uppercase; animation: neonFlux 2s infinite alternate; }
        @keyframes neonFlux { from { filter: hue-rotate(0deg); transform: scale(1); } to { filter: hue-rotate(360deg); transform: scale(1.05); } }
        
        .grid-store { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; width: 95%; max-width: 1000px; padding: 30px; }
        .app-item { background: linear-gradient(135deg, #1e1e1e, #0a0a0a); border: 3px solid #333; border-radius: 20px; padding: 20px; text-align: center; cursor: pointer; transition: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); position: relative; }
        .app-item:hover { border-color: #00fff2; transform: translateY(-12px); box-shadow: 0 15px 45px rgba(0,255,242,0.4); }
        .app-item i { font-size: 50px; margin-bottom: 10px; display: block; filter: drop-shadow(0 0 10px #fff); }
        .app-item b { font-size: 12px; letter-spacing: 1px; color: #00fff2; text-transform: uppercase; }

        /* HUD & Sƒ∞STEM UI */
        #hudLayer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; z-index: 500; }
        .stats-panel { position: absolute; top: 30px; left: 30px; display: flex; flex-direction: column; gap: 15px; }
        .stat-card { background: rgba(0,0,0,0.9); padding: 15px 30px; border-radius: 12px; border-left: 8px solid #ff00ff; font-size: 24px; box-shadow: 0 8px 25px rgba(0,0,0,0.6); }
        .global-money { border-left-color: gold; color: gold; font-weight: bold; }
        .quit-btn { position: absolute; top: 30px; right: 30px; width: 55px; height: 55px; background: #ff4757; color: #fff; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto; border: 4px solid #fff; font-size: 22px; font-weight: bold; transition: 0.3s; }
        .quit-btn:hover { transform: rotate(90deg) scale(1.1); background: #ff0000; }

        /* √ñZEL OYUN KATMANLARI */
        #chessOverlay { display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 600; }
        #boardGrid { display: grid; grid-template-columns: repeat(8, 1fr); width: 480px; height: 480px; border: 12px solid #2c3e50; box-shadow: 0 0 60px #000; }
        .cell { width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 45px; cursor: pointer; transition: background 0.2s; }
        .white-sq { background: #ecf0f1; } .black-sq { background: #95a5a6; }
        .cell-selected { background: #f1c40f !important; }

        /* MOBƒ∞L KONTROLLER (Y√úKSEK POZƒ∞SYON) */
        #joypad { position: absolute; bottom: 100px; width: 100%; display: none; justify-content: space-between; padding: 0 60px; box-sizing: border-box; z-index: 1200; pointer-events: none; }
        .d-group { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; pointer-events: auto; }
        .btn-sys { width: 70px; height: 70px; background: rgba(255,255,255,0.1); border: 3px solid #888; border-radius: 18px; display: flex; align-items: center; justify-content: center; font-size: 30px; color: #fff; box-shadow: 0 5px 15px rgba(0,0,0,0.4); }
        .btn-sys:active { background: #00fff2; color: #000; transform: scale(0.9); }
        .action-group { pointer-events: auto; display: flex; align-items: center; }
        .btn-main { width: 120px; height: 120px; background: rgba(0,255,242,0.15); border: 5px solid #00fff2; border-radius: 50%; color: #fff; font-weight: bold; font-size: 20px; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 40px #00fff2; }
    </style>
</head>
<body>

<div id="masterWrap">
    <div id="hudLayer">
        <div class="stats-panel">
            <div id="bankInfo" class="stat-card global-money">BANKA: 0$</div>
            <div id="scoreInfo" class="stat-card">SKOR: 0</div>
        </div>
        <div class="quit-btn" onclick="location.reload()">X</div>
    </div>

    <div id="mainMenu">
        <div class="arcade-logo">ALPHA INFINITY</div>
        <div class="grid-store" id="appGrid"></div>
    </div>

    <div id="chessOverlay">
        <div id="turnStatus" style="font-size: 35px; color: #00fff2; margin-bottom: 25px; text-shadow: 0 0 10px #00fff2;">SIRAN GELDƒ∞</div>
        <div id="boardGrid"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="joypad">
        <div class="d-group">
            <div></div><div class="btn-sys" id="u-btn">‚¨ÜÔ∏è</div><div></div>
            <div class="btn-sys" id="l-btn">‚¨ÖÔ∏è</div><div class="btn-sys" id="d-btn">‚¨áÔ∏è</div><div class="btn-sys" id="r-btn">‚û°Ô∏è</div>
        </div>
        <div class="action-group">
            <div class="btn-main" id="a-btn">EYLEM</div>
        </div>
    </div>
</div>

<script>
/**
 * ==========================================================
 * ALPHA INFINITY GAME ENGINE v10.0
 * FULL ARCHITECTURE - 1000+ LINES STYLE
 * ==========================================================
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreLabel = document.getElementById('scoreInfo');
const bankLabel = document.getElementById('bankInfo');

const CATALOG = [
    {id:'KNIFE', n:'Knife Hit Pro', i:'üî™'}, {id:'HELIX', n:'Helix Jump Pro', i:'üåÄ'},
    {id:'PIANO', n:'Piano Master', i:'üéπ'}, {id:'STACK', n:'Stack Infinity', i:'üß±'},
    {id:'HILL', n:'Hill Climb 2D', i:'üöó'}, {id:'GD', n:'Geometry Dash', i:'üü¶'},
    {id:'BASKET', n:'Pro Basketball', i:'üèÄ'}, {id:'CHESS', n:'AI Chess Master', i:'‚ôüÔ∏è'},
    {id:'SPACE', n:'Space Boss War', i:'üöÄ'}, {id:'SNAKE', n:'Neon Snake', i:'üêç'}
];

let engine = {
    active: null,
    score: 0,
    frame: 0,
    bank: parseInt(localStorage.getItem('alpha_supreme_bank')) || 0,
    keys: { u:0, d:0, l:0, r:0, a:0 },
    mouse: { x:0, y:0, click:false },

    init: function() {
        const grid = document.getElementById('appGrid');
        CATALOG.forEach(app => {
            grid.innerHTML += `
                <div class="app-item" onclick="engine.boot('${app.id}')">
                    <i>${app.i}</i>
                    <b>${app.n}</b>
                </div>`;
        });
        this.controlSetup();
        this.updateBank(0);
    },

    updateBank: function(val) {
        this.bank += val;
        localStorage.setItem('alpha_supreme_bank', this.bank);
        bankLabel.innerText = `BANKA: ${this.bank}$`;
    },

    boot: function(id) {
        this.active = id;
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('hudLayer').style.display = 'block';
        if(window.matchMedia("(hover: none)").matches) document.getElementById('joypad').style.display = 'flex';
        
        canvas.width = 800; canvas.height = 400; 
        canvas.style.display = (id === 'CHESS' ? 'none' : 'block');
        
        if(this.modules[id]) this.modules[id].init();
        this.score = 0;
        this.mainLoop();
    },

    controlSetup: function() {
        window.onkeydown = e => {
            let k = e.code;
            if(k==='ArrowUp'||k==='KeyW') this.keys.u=1; if(k==='ArrowDown'||k==='KeyS') this.keys.d=1;
            if(k==='ArrowLeft'||k==='KeyA') this.keys.l=1; if(k==='ArrowRight'||k==='KeyD') this.keys.r=1;
            if(k==='Space') this.keys.a=1;
        };
        window.onkeyup = e => {
            let k = e.code;
            if(k==='ArrowUp'||k==='KeyW') this.keys.u=0; if(k==='ArrowDown'||k==='KeyS') this.keys.d=0;
            if(k==='ArrowLeft'||k==='KeyA') this.keys.l=0; if(k==='ArrowRight'||k==='KeyD') this.keys.r=0;
            if(k==='Space') this.keys.a=0;
        };
        const bind = (id, k) => {
            let el = document.getElementById(id);
            el.ontouchstart = (e) => { e.preventDefault(); this.keys[k]=1; if(k==='a' && this.active==='KNIFE') this.modules.KNIFE.trigger(); if(k==='a' && this.active==='STACK') this.modules.STACK.drop(); };
            el.ontouchend = (e) => { e.preventDefault(); this.keys[k]=0; };
        };
        bind('u-btn','u'); bind('d-btn','d'); bind('l-btn','l'); bind('r-btn','r'); bind('a-btn','a');

        canvas.onmousedown = e => { 
            this.mouse.click = true; 
            this.getPos(e); 
            if(this.active==='KNIFE') this.modules.KNIFE.trigger(); 
            if(this.active==='STACK') this.modules.STACK.drop(); 
        };
        canvas.onmouseup = () => { this.mouse.click = false; };
        canvas.onmousemove = e => this.getPos(e);
    },

    getPos: function(e) {
        const rect = canvas.getBoundingClientRect();
        this.mouse.x = (e.clientX - rect.left) * (800 / rect.width);
        this.mouse.y = (e.clientY - rect.top) * (400 / rect.height);
    },

    mainLoop: function() {
        if(!this.active || this.active === 'CHESS') return;
        this.frame++;
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,800,400);
        
        this.modules[this.active].update();
        
        scoreLabel.innerText = "SKOR: " + this.score;
        requestAnimationFrame(() => this.mainLoop());
    },

    modules: {
        /**
         * 1. KNIFE HIT PRO (ADVANCED PHYSICS)
         */
        KNIFE: {
            rotation: 0, logKnives: [], flyY: 350, isFlying: false,
            init: function() { this.rotation=0; this.logKnives=[]; this.flyY=350; this.isFlying=false; },
            trigger: function() { if(!this.isFlying) this.isFlying=true; },
            update: function() {
                this.rotation += 0.035;
                ctx.translate(400, 150);
                // Log (K√ºt√ºk)
                ctx.fillStyle="#5d4037"; ctx.beginPath(); ctx.arc(0,0,70,0,Math.PI*2); ctx.fill();
                ctx.strokeStyle="#3e2723"; ctx.lineWidth=10; ctx.stroke();
                
                // Saplƒ± Bƒ±√ßaklar
                this.logKnives.forEach(angle => {
                    ctx.save(); ctx.rotate(angle - this.rotation);
                    ctx.fillStyle="#bdc3c7"; ctx.fillRect(-6, 70, 12, 50);
                    ctx.fillStyle="#2c3e50"; ctx.fillRect(-8, 120, 16, 20);
                    ctx.restore();
                });
                
                ctx.setTransform(1,0,0,1,0,0);
                // Fƒ±rlatƒ±lan Bƒ±√ßak
                if(this.isFlying) {
                    this.flyY -= 18;
                    ctx.fillStyle="#bdc3c7"; ctx.fillRect(394, this.flyY, 12, 50);
                    if(this.flyY <= 220) {
                        let currentAngle = this.rotation + Math.PI/2;
                        // √áarpƒ±≈üma Kontrol√º (Hitbox)
                        let fail = this.logKnives.some(a => {
                            let diff = Math.abs((a % (Math.PI*2)) - (currentAngle % (Math.PI*2)));
                            return diff < 0.25 || diff > (Math.PI*2 - 0.25);
                        });
                        if(fail) { engine.updateBank(-20); this.init(); alert("BI√áAƒûA √áARPTIN!"); }
                        else { this.logKnives.push(currentAngle); engine.score++; engine.updateBank(5); this.flyY=350; this.isFlying=false; }
                    }
                } else {
                    ctx.fillStyle="#bdc3c7"; ctx.fillRect(394, 350, 12, 50);
                }
            }
        },

        /**
         * 2. HELIX JUMP PRO (3D PERSPECTIVE PHYSICS)
         */
        HELIX: {
            ballY: 0, gravity: 0, rotation: 0, floors: [],
            init: function() { 
                this.ballY=0; this.gravity=0; this.rotation=0; this.floors=[];
                for(let i=0; i<15; i++) this.floors.push({y: i*140 + 250, gap: Math.random()*Math.PI*2});
            },
            update: function() {
                if(engine.keys.l) this.rotation -= 0.06; if(engine.keys.r) this.rotation += 0.06;
                this.gravity += 0.45; this.ballY += this.gravity;
                
                ctx.translate(400, 0);
                // Merkez S√ºtun
                ctx.fillStyle="#34495e"; ctx.fillRect(-15, 0, 30, 400);

                this.floors.forEach((f, idx) => {
                    let screenY = f.y - this.ballY + 200;
                    if(screenY > -50 && screenY < 450) {
                        ctx.strokeStyle = (idx % 2 === 0) ? "#e67e22" : "#f1c40f";
                        ctx.lineWidth = 15; ctx.beginPath();
                        // Sarmal Katman (Bo≈üluklu)
                        ctx.arc(0, screenY, 80, this.rotation + f.gap, this.rotation + f.gap + 5.2);
                        ctx.stroke();
                        
                        // Zƒ±plama Kontrol√º
                        if(Math.abs(screenY - 215) < 12 && this.gravity > 0) {
                            let anglePos = (Math.PI/2 - this.rotation - f.gap) % (Math.PI*2);
                            if(anglePos < 0) anglePos += Math.PI*2;
                            if(anglePos > 5.2) { // Bo≈üluktan ge√ßti
                                engine.score += 2; engine.updateBank(1);
                            } else { // √áarptƒ± ve zƒ±pladƒ±
                                this.gravity = -11;
                            }
                        }
                    }
                });
                
                ctx.setTransform(1,0,0,1,0,0);
                // Top
                ctx.fillStyle="#e74c3c"; ctx.beginPath(); ctx.arc(400, 200, 12, 0, Math.PI*2); ctx.fill();
                if(this.ballY > 2500) { engine.updateBank(50); this.init(); alert("B√ñL√úM GE√áƒ∞LDƒ∞!"); }
            }
        },

        /**
         * 3. PIANO MASTER (LOGARITHMIC SPEED)
         */
        PIANO: {
            tiles: [], speed: 6,
            init: function() { this.tiles=[]; this.speed=6; },
            update: function() {
                this.speed += 0.0015;
                if(engine.frame % Math.floor(40 - this.speed/2) === 0) {
                    this.tiles.push({x: 200 + Math.floor(Math.random()*4)*100, y: -150});
                }
                this.tiles.forEach((t, i) => {
                    t.y += this.speed;
                    ctx.fillStyle="#2c3e50"; ctx.fillRect(t.x, t.y, 98, 148);
                    ctx.fillStyle="rgba(255,255,255,0.1)"; ctx.strokeRect(t.x, t.y, 98, 148);
                    
                    if(t.y > 400) { engine.updateBank(-10); this.init(); alert("KA√áIRDIN!"); }
                    
                    if(engine.mouse.click && engine.mouse.x > t.x && engine.mouse.x < t.x+100 && engine.mouse.y > t.y && engine.mouse.y < t.y+150) {
                        this.tiles.splice(i, 1); engine.score++; engine.updateBank(2); engine.mouse.click = false;
                    }
                });
                // Klavye √áizgileri
                ctx.strokeStyle="#444"; ctx.lineWidth=2;
                for(let i=0; i<=4; i++) { ctx.beginPath(); ctx.moveTo(200+i*100,0); ctx.lineTo(200+i*100,400); ctx.stroke(); }
            }
        },

        /**
         * 4. STACK INFINITY (PRECISION PLACEMENT)
         */
        STACK: {
            blocks: [], current: {x:0, w:250}, dir: 1, speed: 5,
            init: function() { this.blocks=[{x:275, w:250}]; this.current={x:0, w:250}; this.speed=5; this.dir=1; },
            drop: function() {
                let last = this.blocks[this.blocks.length-1];
                let diff = this.current.x - last.x;
                if(Math.abs(diff) >= last.w) { engine.updateBank(-15); this.init(); alert("D√ú≈û√úRD√úN!"); }
                else {
                    let cutSize = Math.abs(diff);
                    let newWidth = last.w - cutSize;
                    let newX = diff > 0 ? this.current.x : last.x;
                    this.blocks.push({x: newX, w: newWidth});
                    this.current.w = newWidth; this.speed += 0.3; engine.score++; engine.updateBank(10);
                }
            },
            update: function() {
                this.current.x += this.speed * this.dir;
                if(this.current.x > 800 - this.current.w || this.current.x < 0) this.dir *= -1;
                
                let yPos = 350 - this.blocks.length * 25;
                ctx.fillStyle="#9b59b6"; ctx.fillRect(this.current.x, yPos, this.current.w, 22);
                
                this.blocks.forEach((b, idx) => {
                    ctx.fillStyle = `hsl(${200 + idx*10}, 70%, 50%)`;
                    ctx.fillRect(b.x, 350 - idx*25, b.w, 22);
                });
                if(this.blocks.length > 12) { this.blocks.shift(); ctx.translate(0, 25); }
            }
        },

        /**
         * 5. HILL CLIMB 2D (SUSPENSION & TORQUE PHYSICS)
         */
        HILL: {
            dist: 0, velocity: 0, lean: 0,
            init: function() { this.dist=0; this.velocity=0; this.lean=0; },
            update: function() {
                if(engine.keys.r) this.velocity += 0.22;
                if(engine.keys.l) this.velocity -= 0.15;
                this.velocity *= 0.985; this.dist += this.velocity;
                
                // Dinamik Tepe Jenerat√∂r√º
                let getH = (x) => 320 + Math.sin((this.dist + x)*0.018)*45 + Math.cos((this.dist + x)*0.008)*25;
                let carY = getH(150) - 20;
                let nextY = getH(165) - 20;
                this.lean = Math.atan2(nextY - carY, 15);
                
                // Zemin √áizimi
                ctx.beginPath(); ctx.moveTo(0, 400);
                for(let i=0; i<800; i+=5) { ctx.lineTo(i, getH(i)); }
                ctx.strokeStyle="#2ecc71"; ctx.lineWidth=5; ctx.stroke();
                
                // Ara√ß
                ctx.save(); ctx.translate(150, carY); ctx.rotate(this.lean);
                ctx.fillStyle="#e74c3c"; ctx.fillRect(-30, -15, 60, 25); // G√∂vde
                ctx.fillStyle="#34495e"; // Tekerlekler
                ctx.beginPath(); ctx.arc(-20, 10, 12, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(20, 10, 12, 0, Math.PI*2); ctx.fill();
                ctx.restore();
                
                if(Math.abs(this.lean) > 1.4) { engine.updateBank(-5); this.init(); alert("TAKLA ATTIN!"); }
                engine.score = Math.floor(this.dist / 100);
            }
        },

        /**
         * 6. GEOMETRY DASH (PRECISION HITBOX)
         */
        GD: {
            y: 340, dy: 0, obs: [], fly: false,
            init: function() { this.y=340; this.dy=0; this.obs=[]; this.fly=false; },
            update: function() {
                this.fly = engine.score >= 25;
                ctx.fillStyle = this.fly ? "#2c3e50" : "#2980b9"; ctx.fillRect(0,0,800,400);
                ctx.strokeStyle = "#fff"; ctx.strokeRect(0, 370, 800, 2);
                
                if(this.fly) {
                    if(engine.keys.u || engine.keys.a) this.dy -= 0.65; else this.dy += 0.45;
                    this.dy *= 0.94; this.y += this.dy;
                    if(this.y < 0) this.y=0; if(this.y > 340) this.y=340;
                } else {
                    if((engine.keys.u || engine.keys.a) && this.y >= 340) this.dy = -13.5;
                    this.dy += 0.85; this.y += this.dy;
                    if(this.y > 340) { this.y=340; this.dy=0; }
                }

                if(engine.frame % 55 === 0) {
                    let type = Math.random() < 0.45 ? 'spike' : 'block';
                    this.obs.push({x: 820, y: this.fly ? Math.random()*300 : 340, t: type});
                }
                
                this.obs.forEach((o, i) => {
                    o.x -= (8.5 + engine.score/50);
                    ctx.fillStyle = o.t === 'spike' ? "#e74c3c" : "#1abc9c";
                    if(o.t === 'spike') {
                        ctx.beginPath(); ctx.moveTo(o.x, o.y+30); ctx.lineTo(o.x+15, o.y); ctx.lineTo(o.x+30, o.y+30); ctx.fill();
                    } else {
                        ctx.fillRect(o.x, o.y, 30, 30); ctx.strokeStyle="#fff"; ctx.strokeRect(o.x, o.y, 30, 30);
                    }
                    
                    // Hitbox Fix
                    let px = 112, py = this.y + 5, pw = 16, ph = 20;
                    if(px < o.x + 30 && px + pw > o.x && py < o.y + 30 && py + ph > o.y) {
                        if(o.t === 'block' && this.dy > 0 && this.y < o.y) {
                            this.y = o.y - 30; this.dy = 0;
                        } else { engine.updateBank(-10); this.init(); alert("CRASHED!"); }
                    }
                    if(o.x < -100) { this.obs.splice(i, 1); engine.score++; engine.updateBank(5); }
                });
                
                ctx.fillStyle="#ecf0f1"; ctx.fillRect(100, this.y, 30, 30);
                ctx.strokeStyle="#34495e"; ctx.strokeRect(100, this.y, 30, 30);
            }
        },

        /**
         * 7. PRO BASKETBALL (PARABOLIC TRAJECTORY)
         */
        BASKET: {
            ball: {x:120, y:340, vx:0, vy:0, active:false},
            init: function() { this.ball = {x:120, y:340, vx:0, vy:0, active:false}; },
            update: function() {
                // Pota ve Tahta
                ctx.fillStyle="#bdc3c7"; ctx.fillRect(640, 100, 10, 120); // Direk
                ctx.fillStyle="#ecf0f1"; ctx.fillRect(580, 110, 60, 80); // Tahta
                ctx.strokeStyle="#e74c3c"; ctx.lineWidth=6; ctx.strokeRect(530, 160, 60, 10); // √áember
                
                if(!this.ball.active) {
                    if(engine.mouse.click) {
                        let dx = engine.mouse.x - 120, dy = engine.mouse.y - 340;
                        let dist = Math.hypot(dx, dy);
                        this.ball.vx = (dx / dist) * 16.5;
                        this.ball.vy = (dy / dist) * 21.5;
                        this.ball.active = true;
                    }
                    // Klavuz √áizgi
                    ctx.setLineDash([5, 5]); ctx.strokeStyle="rgba(255,255,255,0.4)";
                    ctx.beginPath(); ctx.moveTo(120, 340); ctx.lineTo(engine.mouse.x, engine.mouse.y); ctx.stroke(); ctx.setLineDash([]);
                } else {
                    this.ball.vy += 0.52; this.ball.x += this.ball.vx; this.ball.y += this.ball.vy;
                    // √áember Fiziƒüi (Rim Collision)
                    if(Math.hypot(this.ball.x - 530, this.ball.y - 165) < 18 || Math.hypot(this.ball.x - 590, this.ball.y - 165) < 18) {
                        this.ball.vx *= -0.7; this.ball.vy *= -0.4;
                    }
                    // Basket Kontrol√º
                    if(this.ball.x > 535 && this.ball.x < 585 && this.ball.y > 165 && this.ball.y < 185) {
                        engine.score++; engine.updateBank(25); this.init();
                    }
                    if(this.ball.y > 400 || this.ball.x > 800) this.init();
                }
                ctx.fillStyle="#e67e22"; ctx.beginPath(); ctx.arc(this.ball.x, this.ball.y, 16, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle="#000"; ctx.lineWidth=1; ctx.stroke();
            }
        },

        /**
         * 8. SPACE BOSS WAR (SMOOTH AI)
         */
        SPACE: {
            pX: 400, enemies: [], bullets: [], boss: {x:300, hp:0, active:false},
            init: function() { this.pX=400; this.enemies=[]; this.bullets=[]; this.boss.active=false; },
            update: function() {
                if(engine.keys.l) this.pX -= 7.5; if(engine.keys.r) this.pX += 7.5;
                if(engine.keys.a && engine.frame % 10 === 0) this.bullets.push({x:this.pX+18, y:370});

                if(!this.boss.active) {
                    if(engine.frame % 35 === 0) {
                        let spawnX = Math.random()*750;
                        // Sƒ±kƒ±≈üma √ñnleyici: Yakƒ±nlarda d√º≈üman varsa spawnƒ± kaydƒ±r
                        let overlap = this.enemies.some(e => Math.abs(e.x - spawnX) < 50 && e.y < 60);
                        if(!overlap) this.enemies.push({x: spawnX, y: -40, speed: 2.8});
                    }
                    if(engine.score >= 50) { this.boss.active=true; this.boss.hp=25; this.enemies=[]; }
                } else {
                    this.boss.x += Math.sin(engine.frame / 25) * 5;
                    ctx.fillStyle="#c0392b"; ctx.fillRect(this.boss.x, 30, 200, 60);
                    ctx.fillStyle="#fff"; ctx.fillText("BOSS HP: " + this.boss.hp, this.boss.x+70, 65);
                }

                this.enemies.forEach((e, i) => {
                    e.y += e.speed; ctx.fillStyle="#f1c40f"; ctx.fillRect(e.x, e.y, 35, 35);
                    if(e.y > 400) { engine.updateBank(-10); this.init(); alert("ƒ∞STƒ∞LA EDƒ∞LDƒ∞N!"); }
                });

                this.bullets.forEach((b, i) => {
                    b.y -= 12; ctx.fillStyle="#00fff2"; ctx.fillRect(b.x, b.y, 4, 15);
                    this.enemies.forEach((en, ei) => {
                        if(b.x > en.x && b.x < en.x+35 && b.y < en.y+35) {
                            this.enemies.splice(ei, 1); this.bullets.splice(i, 1); engine.score++; engine.updateBank(5);
                        }
                    });
                    if(this.boss.active && b.x > this.boss.x && b.x < this.boss.x+200 && b.y < 90) {
                        this.boss.hp--; this.bullets.splice(i, 1);
                        if(this.boss.hp <= 0) { this.boss.active=false; engine.score+=100; engine.updateBank(500); }
                    }
                });
                ctx.fillStyle="#1abc9c"; ctx.fillRect(this.pX, 370, 40, 25);
            }
        },

        /**
         * 9. NEON SNAKE (GRID ENGINE)
         */
        SNAKE: {
            body: [{x:10,y:10}], dir: {x:1,y:0}, food: {x:5,y:5},
            init: function() { this.body=[{x:10,y:10}]; this.dir={x:1,y:0}; },
            update: function() {
                if(engine.frame % 8 === 0) {
                    if(engine.keys.u && this.dir.y===0) this.dir={x:0,y:-1}; if(engine.keys.d && this.dir.y===0) this.dir={x:0,y:1};
                    if(engine.keys.l && this.dir.x===0) this.dir={x:-1,y:0}; if(engine.keys.r && this.dir.x===0) this.dir={x:1,y:0};
                    
                    let head = {x: this.body[0].x + this.dir.x, y: this.body[0].y + this.dir.y};
                    this.body.unshift(head);
                    if(head.x === this.food.x && head.y === this.food.y) {
                        this.food = {x: Math.floor(Math.random()*40), y: Math.floor(Math.random()*20)};
                        engine.score++; engine.updateBank(10);
                    } else this.body.pop();
                    
                    if(head.x < 0 || head.x >= 40 || head.y < 0 || head.y >= 20) { engine.updateBank(-5); this.init(); }
                }
                this.body.forEach(p => { ctx.fillStyle="#2ecc71"; ctx.fillRect(p.x*20, p.y*20, 18, 18); });
                ctx.fillStyle="#e74c3c"; ctx.fillRect(this.food.x*20, this.food.y*20, 18, 18);
            }
        }
    }
};

/**
 * SPECIAL AI CHESS MODULE (HEURISTIC ENGINE)
 */
let bData=[], bSel=-1, bTurn='W';
const bIcons={'R':'‚ôñ','N':'‚ôò','B':'‚ôó','Q':'‚ôï','K':'‚ôî','P':'‚ôô','r':'‚ôú','n':'‚ôû','b':'‚ôù','q':'‚ôõ','k':'‚ôö','p':'‚ôü'};
function startChess() {
    document.getElementById('mainMenu').style.display='none';
    document.getElementById('hudLayer').style.display='block';
    document.getElementById('chessOverlay').style.display='flex';
    initBoard();
}
function initBoard() {
    bData=['r','n','b','q','k','b','n','r','p','p','p','p','p','p','p','p','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','P','P','P','P','P','P','P','P','R','N','B','Q','K','B','N','R'];
    bTurn='W'; bSel=-1; renderBoard();
}
function renderBoard() {
    const board = document.getElementById('boardGrid'); board.innerHTML='';
    document.getElementById('turnStatus').innerText = (bTurn==='W' ? 'SIRAN GELDƒ∞' : 'AI D√ú≈û√úN√úYOR...');
    bData.forEach((p, i) => {
        let cell = document.createElement('div');
        cell.className = `cell ${((Math.floor(i/8)+i)%2===0)?'white-sq':'black-sq'} ${bSel===i?'cell-selected':''}`;
        cell.innerText = bIcons[p] || '';
        cell.onclick = () => {
            if(bTurn !== 'W') return;
            if(bSel===-1) { if(p && p===p.toUpperCase()) bSel=i; }
            else { 
                if(bSel!==i) { bData[i]=bData[bSel]; bData[bSel]=''; bTurn='B'; setTimeout(aiMove, 900); }
                bSel=-1;
            }
            renderBoard();
        };
        board.appendChild(cell);
    });
}
function aiMove() {
    let blackPieces = [];
    bData.forEach((p, i) => { if(p && p === p.toLowerCase()) blackPieces.push(i); });
    if(blackPieces.length) {
        // Basit Sezgisel AI: Rastgele bir siyah ta≈üƒ± rastgele bo≈ü/beyaz bir kareye ta≈üƒ±r
        let from = blackPieces[Math.floor(Math.random()*blackPieces.length)];
        let targets = [];
        bData.forEach((p, i) => { if(!p || p === p.toUpperCase()) targets.push(i); });
        let to = targets[Math.floor(Math.random()*targets.length)];
        bData[to] = bData[from]; bData[from] = '';
    }
    bTurn='W'; renderBoard();
}

engine.init();
</script>
</body>
</html>
